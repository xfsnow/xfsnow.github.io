<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Snowpeak Blog</title><meta name="description" content="Sharing and discussing cutting-edge technologies of AI and cloud computing, and other interesting topics."><meta name="keywords" content="AI, GitHub Copilot, Azure Cloud, Cloud Computing, Front-end Technology, Back-end Technology, Web Development, Software Engineering"><link rel="stylesheet" href="/assets/css/style.min.css"><link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.7.2/css/all.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script></head><body><nav class="navbar"><div class="nav-container"><div class="nav-logo"><h2><i class="fas fa-snowflake"></i> Snowpeak</h2></div><div class="nav-menu"><a href="/en/" class="nav-link">Home</a><a href="/en/page_1.htm" class="nav-link">Article</a><a href="/en#tools" class="nav-link">Tools</a><a href="/en/about.htm" class="nav-link">About</a><a href="/" class="nav-link lang-switch"><i class="fas fa-globe"></i> 简体中文</a></div><div class="nav-toggle" id="mobile-menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></div></div></nav><header class="article-header"><div class="container"><h1>JavaScript Classes and Class Generator Tool</h1><div class="article-meta"><span><i class="fas fa-calendar"></i> Published: 2011-04-20 17:56:00</span><span><i class="fas fa-clock"></i> Reading time: 43 minutes </span><span><i class="fas fa-tag"></i> Category: Frontend</span></div></div></header><main class="article-container"><h2>Overview</h2><h3>Who Should Read This Document?</h3><p>This article provides an in-depth explanation of JavaScript class-related knowledge and introduces some advanced features for improving object-oriented programming in JavaScript. It is suitable for friends who are familiar with JavaScript, understand JavaScript basic syntax, and have some JavaScript development experience.</p><h3>What is the Use of This Document?</h3><p>The content introduced in this document is suitable for large-scale JavaScript development, especially when extensively using object-oriented programming with class declarations and inheritance.</p><h3>Significance</h3><p>By definition, JavaScript is a prototype-based (prototype-based) object-oriented (object-oriented) scripting language that has all the main features of object-oriented languages and can fully implement object-oriented programming. Due to JavaScript's prototype-based characteristic, using the syntax supported by the language itself for class declaration and inheritance is quite different from the syntax used in other mainstream object-oriented languages. Creating a convenient class generator (Class Creator) to implement class-based (class-based) programming syntax inheritance will greatly facilitate object-oriented JavaScript programming. It not only conforms to programmers' familiar thinking patterns of class inheritance and improves development efficiency, but also reduces code volume and improves the efficiency of JavaScript program parsing and execution.</p><p>When conducting large-scale JavaScript development, object-oriented writing is used extensively, making the role of class generators even more important. Class generators have become an indispensable core component of JavaScript basic class libraries, such as Prototype library's <a href="http://api.prototypejs.org/language/Class/create/">Class.create()</a> and extJs's <a href="http://dev.sencha.com/deploy/dev/docs/source/ComponentMgr.html#method-Ext-create">Ext.create()</a> and <a href="http://dev.sencha.com/deploy/dev/docs/source/Ext.html#method-Ext-extend">Ext.extend()</a>.</p><h2>JavaScript's Built-in Prototype-based Class Usage</h2><h3>Class Declaration</h3><p>JavaScript itself supports the use of classes, but it is prototype-based, and its syntax is different from what we are familiar with in other languages. Let's first look at JavaScript's built-in class usage. The following examples and explanations are from "JavaScript: The Definitive Guide, 5th Edition". Its cover features a rhinoceros, and familiar JavaScript friends affectionately call it the "rhino book" based on its cover.</p><p>A class can be declared with the following code:</p> <pre><code class="language-javascript">// Use a function as a constructor. Its role is to initialize property values that are different for each instance.
function Rectangle(w, h) {
    this.width = w;
    this.height = h;
}

// When we need members that are shared by all instances, we put these members in the prototype object.
Rectangle.prototype.area = function() {
    return this.width * this.height;
}
</code></pre> <p>With the above code, we have declared a Rectangle class. Each instance will have different properties width and height. In "The Definitive Guide," such members are called instance properties (instance property) or instance methods (instance method). They share a method area(). In "The Definitive Guide," such members are called class properties (class property) or class methods (class method). This effect can be verified with the following code:</p> <pre><code class="language-javascript">var r = new Rectangle(2, 3);
r.hasOwnProperty(&quot;width&quot;);  // true: width is a direct property of r
r.hasOwnProperty(&quot;area&quot;);   // false: area is an inherited property of r
&quot;area&quot; in r;                // true: &quot;area&quot; is a property of r
</code></pre> <p>JavaScript's core principle when instantiating an object with the new keyword is through "prototype". A constructor is a function that provides the name for this "class" of objects and initializes property values that are different for each instance. The constructor function is associated with a prototype object. Each object instance initialized using this constructor function will have a set of identical properties and methods from this prototype. Object instances having prototype properties and methods is not achieved by copying prototype members to each instance, but through the process of looking up members. That is, when JavaScript encounters a call to a member of an object, it first looks for the object's own instance properties or instance methods. If not found, it continues to look up the class properties or class methods in the prototype of the object's class constructor.</p><p>JavaScript's mechanism has two implications. First, using prototype to implement member sharing can save a lot of memory. Second, since members are looked up and called at runtime, even after an object is instantiated, if members are added to the prototype, the object instance can use these newly added members (although this is not recommended).</p><p>The following image from "The Definitive Guide" visually illustrates the principle of runtime object member lookup and usage.</p><p><img alt="JavaScript Object Instance Method Lookup and Call Demonstration" src="../assets/img/20110420_JavaScript_01.webp"></p><h3>Class Inheritance</h3><p>Let's explain JavaScript's native class inheritance usage with the following example. Based on the previous Rectangle class declaration, we'll inherit a subclass from it.</p> <pre><code class="language-javascript">function PositionedRectangle(x, y, w, h) {
    //First, call the parent class constructor in the new object's constructor method using the call method to apply the parent class constructor to the current class instantiated object.
    //This practice is called constructor chaining. Many class inheritance languages have this practice.
    Rectangle.call(this, w, h);

    // Now add two properties to the current class.
    this.x = x;
    this.y = y;
}

// If we use the default prototype object, we'll only get a subclass of the default Object class.
// To inherit the Rectangle class, we must explicitly create our own prototype object and specify it as new Rectangle() to get Rectangle's prototype object.
PositionedRectangle.prototype = new Rectangle();

// The prototype object of the previous constructor was created using the Rectangle() constructor. The prototype object has a constructor property pointing to the constructor itself, so each object instance can know which function is its constructor through the constructor.
// We want the object instances of the current subclass PositionedRectangle to have their own constructor. We can explicitly specify it as follows.
PositionedRectangle.prototype.constructor = PositionedRectangle;

// Now that we've prepared the subclass prototype object, we can add new instance methods to it.
PositionedRectangle.prototype.contains = function(x, y) {
    return (x &gt; this.x &amp;&amp; x &lt; this.x + this.width &amp;&amp; y &gt; this.y &amp;&amp; y &lt; this.y + this.height);
}
</code></pre> <p>After declaring this subclass as above, we can use it.</p> <pre><code class="language-javascript">var pr = new PositionedRectangle(2, 2, 2, 2);
pr.contains(3, 3);                     // Call own instance method
pr.area();                             // Call inherited instance method from parent class

// Call parent and own properties the same way
pr.x + &quot;, &quot; + pr.y + &quot;, &quot; + pr.width + &quot;, &quot; + pr.height;

// This object instance is an instance of the following 3 classes
pr instanceof PositionedRectangle     // true
pr instanceof Rectangle               // true
pr instanceof Object                  // true
</code></pre> <h2>Step-by-Step Creation of a Class Generator</h2><p>The above examples show that JavaScript fully supports class declaration and inheritance, but it is indeed somewhat cumbersome to use. Friends familiar with mainstream JavaScript basic class libraries may know some class generator usages. Let's create a class generator ourselves.</p><p>Essentially, a class generator tool function encapsulates the JavaScript class writing method discussed earlier. Let's first clarify our goals and then implement them step by step.</p><ol><li>Simplify class definition syntax. Instead of writing constructors separately and defining methods in prototype one by one, pass in a concise JSON structure and convert it to a class definition. Use as constructor method name, and the constructor method is optional.</li><li>Basic class inheritance, inheriting only one class at a time</li><li>Support instanceof method to detect if an object is an instance of a class</li><li>Subclasses can call parent class methods, either calling parent class methods with different names or calling parent class methods with the same name.</li></ol><h3>Step Zero, First Give Our Class Generator Tool Function a Function Name</h3><p>Let's clarify again that a class generator is essentially a tool function. It receives parameters related to class definition and returns a constructor function for instantiating objects. Based on the basic knowledge of JavaScript class usage introduced earlier, this returned constructor function also has its prototype object and related properties and methods. Just use new to instantiate different object instances. So a class generator itself is not a class definition; it is a regular function. According to common class library naming conventions, this function name should be all lowercase. Let's call it classer, meaning "a tool for making classes."</p><h3>Step One, First Simplify Class Definition Syntax</h3><p>Pass in a JSON structure and convert it to the constructor function and prototype object required for class definition and related properties and methods. It's essentially organizing JavaScript's separate declaration of constructor functions and prototype methods together.<br> We agree to use __init as the constructor method name, and the constructor method is optional.</p> <pre><code class="language-javascript">// Only one parameter, which is the class definition
var classer = function(aDefine) {
    //Agree that the constructor function name is __init()
    var constructorName = '__init';

    //The type is the constructor function. If there is no __init(), use the default root class Object's constructor function
    var aType = aDefine[constructorName] ? aDefine[constructorName] : Object;
    var aPrototype = aType.prototype;

    for (var member in aDefine)  //Copy class definition to current class prototype
    {
        if(constructorName != member)  //Constructor function doesn't need to be copied
        {
            aPrototype[member] = aDefine[member];
        }
    }

    return aType;
};
</code></pre> <p>With this most basic class generator, we can define classes more simply. For example:</p> <pre><code class="language-javascript">var Animal = classer({
    __init: function(name) {
        this.name = name;
    },

    getName: function() {
        return this.name;
    }
});

// Instantiate an object and test it.
var animal = new Animal('animal');
animal instanceof Animal;  // true
animal.getName();          // &quot;animal&quot;
</code></pre> <h3>Step Two, Implement Class Inheritance</h3><p>Here we use Li Zhan's Ganlu model writing. When there is one parameter, it is a class definition. When there are two parameters, the first one is the base class and the second one is the current class definition.</p> <pre><code class="language-javascript">var classer = function() {
    var argLength = arguments.length;
    var aDefine = arguments[argLength-1];  //The last parameter is the class definition

    if(aDefine) {
        //Parse the base class. Use the base class when there is one, otherwise use the default root class Object
        var aBase = argLength &gt; 1 ? arguments[0] : Object;

        //Agree that the constructor function name is __init()
        var constructorName = '__init';

        //The type is the constructor function. If there is no __init(), use the default root class constructor function.
        //The classic class inheritance approach is also to call Parent.call(this, arguments); in the Child constructor.
        var aType = aDefine[constructorName] ? aDefine[constructorName] : function() {
            aBase.call(this, arguments);
        };

        //Classic class inheritance is essentially Child.prototype = new Parent(); But just var aPrototype = new aBase(); won't work,
        //because we can't directly access the object's built-in prototype property. We must pass it through a constructor chain.
        //See &quot;Wutou&quot; http://www.cnblogs.com/leadzen/archive/2008/02/25/1073404.html
        function prototype_() {}           //Prepare to pass prototype
        prototype_.prototype = aBase.prototype;  //Establish the prototype to be used by the class. The new object's built-in prototype will be the expected prototype object
        var aPrototype = new prototype_();

        //Copy class definition to current class prototype
        for (var member in aDefine) {
            //Constructor function doesn't need to be copied
            if(constructorName != member) {
                aPrototype[member] = aDefine[member];
            }
        }

        //Set the class (constructor function) prototype
        aType.prototype = aPrototype;
        //Set the class constructor
        aType.prototype.constructor = aType;

        return aType;
    }
};
</code></pre> <p>After the above expansion, we can now inherit classes very conveniently. Based on the previous Animal class, we inherit a subclass Dog.</p> <pre><code class="language-javascript">var Dog = classer(Animal, {
    __init: function(name) {
        this.name = name;
    },

    bark: function() {
        return 'woof';
    }
});

// Instantiate an object and test it.
var dog = new Dog('dog');
dog instanceof Dog       // true
dog instanceof Animal    // true
dog instanceof Object    // true
dog.getName()            // &quot;dog&quot;
dog.bark()               // &quot;woof&quot;
</code></pre> <h3>Finally, Let's Implement Calling Parent Class Members in Subclass Declarations</h3><p>In the process of assembling prototype object members above, the parent class members have been assembled into the subclass prototype object. Therefore, subclass method declarations can directly use parent class members, except when a subclass method needs to call a parent class method with the same name. Now we'll借鉴 John Resig's solution to solve this problem.</p> <pre><code class="language-javascript">var classer = function() {
    var argLength = arguments.length;
    var aDefine = arguments[argLength-1];  //The last parameter is the class definition

    if(aDefine) {
        //Parse the base class. Use the base class when there is one, otherwise use the default root class Object
        var aBase = argLength &gt; 1 ? arguments[0] : Object;

        //Agree that the constructor function name is __init()
        var constructorName = '__init';

        //The type is the constructor function. If there is no __init(), use the default root class constructor function.
        //The classic class inheritance approach is also to call Parent.call(this, arguments); in the Child constructor.
        //Classic class inheritance is essentially Child.prototype = new Parent(); But just var aPrototype = new aBase(); won't work,
        //because we can't directly access the object's built-in prototype property. We must pass it through a constructor chain.

        // Add _super() method to implement the current class method calling the parent class method with the same name
        var _super = aBase.prototype;

        //Construct a temporary function for the prototype to connect the prototype chain
        function prototype_() {}           //Prepare to pass prototype
        prototype_.prototype = _super;

        //Establish the prototype to be used by the class. The new object's built-in prototype will be the expected prototype object
        var aPrototype = new prototype_();

        //Copy class definition to current class prototype
        for (var member in aDefine) {
            aPrototype[member] = (
                (&quot;function&quot; == typeof aDefine[member]) &amp;&amp; 
                (&quot;function&quot; == typeof _super[member])
            ) ? (function(member, fn) {
                return function() {
                    // The _super method is just temporarily added, so first backup the original this._super to tmp, then restore it to the original this._super = tmp after binding;
                    // As for the binding approach, what I can understand now is var ret = fn.apply(this, arguments); applying fn to the current object's this,
                    // Finally, the returned return ret; is this function. This realizes that this._super() can be called in each method of the class definition, the method names are the same, but their contents are different!
                    var tmp = this._super;

                    // Add a ._super() method to the current method in the parent class
                    this._super = _super[member];

                    // This method is only temporarily bound, so after execution we delete it again.
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;

                    return ret;
                };
            })(member, aDefine[member]) : aDefine[member];
        }

        // To implement calling the parent class constructor with the same name in the constructor method, we need to put the constructor method definition after copying prototype members.
        // And the program statements are more natural: use your own constructor method if you have one, otherwise use the parent's.
        var aType = aDefine[constructorName] ? aPrototype[constructorName] : _super[constructorName];

        //Set the class (constructor function) prototype
        aType.prototype = aPrototype;
        //Set the class constructor
        aType.prototype.constructor = aType;

        return aType;
    }
};
</code></pre> <p>Finally, let's demonstrate our results and test them. Note that in subclass definitions, <code>_super()</code> methods can be used in different methods, and they point to different methods in the parent class!</p> <pre><code class="language-javascript">var Person = classer(Animal, {
    __init: function(name, sex) {
        this.sex = sex;
        this._super(name);
    },

    getName: function() {
        return 'Person says ' + this._super();
    },

    getSex: function() {
        return this.sex;
    }
});

var p = new Person('boy', 'male');
p instanceof Person     // true
p instanceof Animal     // true
p instanceof Object     // true
p.getName()             // &quot;Person says boy&quot;
p.getSex()              // &quot;male&quot;
</code></pre> <p>The above class generator code and explanations reference Li Zhan's <a href="http://www.cnblogs.com/leadzen/archive/2008/06/04/1213090.html">"Wutou JavaScript" Ganlu Model</a> and <a href="http://ejohn.org/blog/simple-javascript-inheritance/">John Resig's Simple JavaScript Inheritance</a>.</p><p>Our final class generator classer function adopts the two-parameter approach of the Ganlu model because I personally prefer this approach. Its usage habits are basically consistent with the class-based declaration approach commonly used by everyone. Whether declaring a new class or inheriting a class, the classer() function is uniformly called, which looks clearer and more understandable than John Resig's approach. John Resig's solution adds an extend() method to the constructor functions of all classes generated by its generator, which I don't like.</p></main><footer class="footer"><div class="container"><div class="footer-content"><div class="footer-section"><h3><i class="fas fa-snowflake"></i> Snowpeak</h3><p>Sharing and discussing cutting-edge technologies of AI and cloud computing, and other interesting topics.</p><div class="social-links"><div class="social-platforms"><a href="https://github.com/xfsnow" target="_blank" class="social-link"><i class="fab fa-github"></i></a><a href="https://snowpeak.blog.csdn.net/" target="_blank" class="social-link"><i class="fas fa-blog"></i></a><a href="https://space.bilibili.com/701839928" target="_blank" class="social-link"><i class="fab fa-bilibili"></i></a><a href="https://www.linkedin.com/in/snowpeak" target="_blank" class="social-link"><i class="fab fa-linkedin"></i></a></div><div class="wechat-section"><div class="wechat-info"><span class="wechat-label">WeChat Account</span><span class="wechat-name">Tech Warm Life</span></div><img src="/assets/img/techwarm.jpg" alt="Tech Warm Life" class="wechat-qr"></div></div></div><div class="footer-section"><h4>Quick Links</h4><ul><li><a href="/#articles">Article</a></li><li><a href="/#tools">Tools</a></li><li><a href="https://docs.github.com/en/pages" target="_blank">GitHub Pages</a></li></ul></div><div class="footer-section"><h4>Tech Stack</h4><ul><li>Python</li><li>GitHub Copilot</li><li>Claude Sonnet 4</li><li>HTML/CSS/JS</li><li>Responsive Design</li></ul></div></div><div class="footer-bottom"><p>Copyright &copy; 2013-<script>document.write((new Date()).getFullYear());</script> Snowpeak Blog. Running on GitHub Pages. <a href="https://beian.miit.gov.cn" target="_blank" class="icp_beian">京ICP备2021007720号</a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502052523" target="_blank" class="gongan_beian">京公网安备11010502052523号</a></p></div></div></footer><script src="/en/index.js"></script><script src="/assets/js/blog.min.js"></script><script>hljs.highlightAll();</script></body></html>