<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Snowpeak Blog</title><meta name="description" content="Sharing and discussing cutting-edge technologies of AI and cloud computing, and other interesting topics."><meta name="keywords" content="AI, GitHub Copilot, Azure Cloud, Cloud Computing, Front-end Technology, Back-end Technology, Web Development, Software Engineering"><link rel="stylesheet" href="/assets/css/style.min.css"><link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.7.2/css/all.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script></head><body><nav class="navbar"><div class="nav-container"><div class="nav-logo"><h2><i class="fas fa-snowflake"></i> Snowpeak</h2></div><div class="nav-menu"><a href="/en/" class="nav-link">Home</a><a href="/en/page_1.htm" class="nav-link">Article</a><a href="/en#tools" class="nav-link">Tools</a><a href="/en/about.htm" class="nav-link">About</a><a href="/" class="nav-link lang-switch"><i class="fas fa-globe"></i> 简体中文</a></div><div class="nav-toggle" id="mobile-menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></div></div></nav><header class="article-header"><div class="container"><h1>A Further Discussion on Implementing Tree Structures with Nested Set Model</h1><div class="article-meta"><span><i class="fas fa-calendar"></i> Published: 2012-06-25 21:39:00</span><span><i class="fas fa-clock"></i> Reading time: 25 minutes </span><span><i class="fas fa-tag"></i> Category: Database</span></div></div></header><main class="article-container"><p>To implement tree structures in relational databases, besides the familiar and easily understood "Adjacency List Model", there is another "Nested Set Model". The basic theory can be found online, such as:</p><p>Mike Hillyer's original work:</p><p><a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/">http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/</a></p><p>Chen Jianping's translation of the above article:</p><p><a href="http://www.cnblogs.com/chinaontology/archive/2010/03/10/NestedSetModel.html">http://www.cnblogs.com/chinaontology/archive/2010/03/10/NestedSetModel.html</a></p><p>And Liu Min's blog has a PDF document整理 of the above translated version that can be downloaded:</p><p><a href="http://www.liumin.name/20071117/acts_as_nested_set/">http://www.liumin.name/20071117/acts_as_nested_set/</a></p><p>This article provides a detailed explanation of the core theory of left and right boundaries, making it easy for everyone to understand the "Nested Set Model" from scratch. However, the example in this article only uses the classic two fields of left and right boundaries. When it comes to node depth, there are too many nested queries, which greatly reduces the performance of SQL execution. Xuefeng combines some workaround solutions learned online and adds a redundant node depth field, reducing query complexity and improving execution performance, making it suitable for real development and production environments.</p><p>This article is based on the above articles, and reading this article requires understanding the basic principles of "Nested Set Model". If you don't understand yet, it is recommended to read the above documents first.</p><p>The scenario case we use is hierarchical regional data. First, let's look at the SQL statement for creating the table:</p> <pre><code class="language-sql">CREATE TABLE `geo` (
  `cid` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `depth` int(11) NOT NULL,
  `lft` int(11) NOT NULL,
  `rgt` int(11) NOT NULL,
  PRIMARY KEY (`cid`),
  KEY `lft` (`lft`),
  KEY `rgt` (`rgt`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;
</code></pre> <p>I only added a depth field to Mike Hillyer's table structure to represent the node depth.</p><p>The following will introduce the main functional requirements of tree structures one by one.</p><h2>Inserting New Nodes</h2><p>First insert a root node. We agree that the depth of the root node is 1. When there is only one root node, its left and right boundaries are naturally 1 and 2, so:</p> <pre><code class="language-sql">INSERT INTO geo (name, depth, lft, rgt) VALUES ('根', 1, 1, 2);
</code></pre> <p>Let's insert a few child nodes one by one to familiarize ourselves with how inserting nodes affects existing nodes.</p><p>The depth of a child node is the current node's depth + 1. According to the mathematical principle of the "Nested Set Model", the left boundary of a child node is the right boundary of the current node, and the right boundary of a child node is the right boundary of the current node plus 1. Also, the left and right boundaries of all nodes to the right of the current node are increased by 2. So:</p> <pre><code class="language-sql">INSERT INTO geo (name, depth, lft, rgt) VALUES ('北京', 1+1, 2, 2+1);
UPDATE geo SET lft=lft+2 WHERE lft&gt;2;
UPDATE geo SET rgt=rgt+2 WHERE rgt&gt;=2;
</code></pre> <p>Insert another child node. At this time, the parent node is still the root node, but its rgt value has been updated to 4, while its depth is still 1, so:</p> <pre><code class="language-sql">INSERT INTO geo (name, depth, lft, rgt) VALUES ('天津', 1+1, 4, 4+1);
UPDATE geo SET lft=lft+2 WHERE lft&gt;4;
UPDATE geo SET rgt=rgt+2 WHERE rgt&gt;=4;
</code></pre> <p>Actually, to insert a child node, you only need to know the current node's rgt and depth, plus the name of the new child node, which can be made into a stored procedure. But the SQL logic is not particularly complex, and it can also be executed in a program as a transaction.</p><p>Below I'll post the SQL for the sample data, which everyone can import directly. Those interested can continue to practice inserting new nodes themselves.</p> <pre><code class="language-sql">INSERT INTO `geo`
 (`cid`, `name`, `depth`, `lft`, `rgt`)
 VALUES
(1, '根', 1, 1, 22),
(2, '北京', 2, 2, 13),
(3, '天津', 2, 14, 19),
(4, '上海', 2, 20, 21),
(5, '东城', 3, 3, 6),
(6, '西城', 3, 7, 8),
(7, '崇文', 3, 9, 10),
(8, '和平', 3, 15, 16),
(9, '宣武', 3, 11, 12),
(10, '南开', 3, 17, 18),
(11, '东华门', 4, 4, 5);
</code></pre> <h2>Querying All Leaf Nodes</h2><p>According to this model, leaf nodes are those nodes whose right boundary is 1 greater than their left boundary. The SQL statement is simple.</p> <pre><code class="language-sql">SELECT cid, name FROM geo WHERE rgt = lft + 1;
</code></pre> <h2>Getting a Single Path</h2><p>That is, querying a node and all its parent nodes. I uniformly replace the BETWEEN keyword with greater than or less than comparison operators. When including equals, it includes itself; when not including equals, it doesn't include itself.</p> <pre><code class="language-sql">SELECT parent.cid, parent.name FROM geo  AS node, geo AS parent
    WHERE parent.lft &lt;= node.lft AND node.lft &lt;= parent.rgt AND node.name = '东华门'
    ORDER BY parent.lft;
</code></pre> <p>Or more accurately using the primary key:</p> <pre><code class="language-sql">SELECT parent.cid, parent.name FROM geo  AS node, geo AS parent
    WHERE parent.lft &lt;= node.lft AND node.lft &lt;= parent.rgt AND node.cid = 11
    ORDER BY parent.lft;
</code></pre> <h2>Querying Node Depth</h2><p>Now we can directly use the redundant depth field instead of complex nested queries.</p> <pre><code class="language-sql">SELECT depth FROM geo WHERE name='南开';
</code></pre> <h2>The Entire Tree and Depth</h2> <pre><code class="language-sql">SELECT depth, name FROM depth;
</code></pre> <p>With some formatting:</p> <pre><code class="language-sql">SELECT depth, CONCAT( REPEAT('- ', depth - 1), name) AS name FROM geo ORDER BY lft;
</code></pre> <h2>Subtree and Depth</h2><p>First, use the left and right boundaries of the subtree's starting point as conditions. For example, Beijing's lft=2, rgt=11. Nested queries are not needed, but an additional query may be required.</p> <pre><code class="language-sql">SELECT depth, CONCAT( REPEAT('- ', depth - 1), name) AS name FROM geo WHERE lft&gt;=2 AND rgt&lt;=11 ORDER BY lft;
</code></pre> <p>Using nested queries, with the subtree's starting point ID as the condition, such as Tianjin's cid=3:</p> <pre><code class="language-sql">SELECT n.depth, CONCAT( REPEAT('- ', n.depth - 1), n.name) AS name
FROM geo AS n , geo AS s
WHERE s.cid=3 AND n.lft&gt;=s.lft AND n.rgt&lt;=s.rgt ORDER BY n.lft;
</code></pre> <h2>Direct Child Nodes</h2><p>That is, the direct subordinates of a node. Also use the redundant depth field to simplify the query.</p><p>First, use the node's left and right boundaries and depth as conditions. For example, the root's lft=1, rgt=20, depth=1. Nested queries are not needed, but an additional query may be required.</p> <pre><code class="language-sql">SELECT cid, depth, name FROM geo WHERE lft&gt;1 AND rgt&lt;22 AND depth=1+1 ORDER BY lft;
</code></pre> <p>Using nested queries, with the subtree's starting point ID as the condition, such as the root's cid=1, Beijing's cid=2:</p> <pre><code class="language-sql">SELECT n.cid, n.depth, n.name
FROM geo AS n, geo AS s
WHERE s.cid=2 AND n.lft&gt;=s.lft AND n.rgt&lt;=s.rgt AND n.depth=s.depth+1 ORDER BY n.lft;
</code></pre> <h2>Direct Parent Node</h2><p>It's essentially LIMIT 1 of a single path. Of course, not including itself, use &lt; instead of &lt;=. Using the primary key ID is still the fastest.</p> <pre><code class="language-sql">SELECT parent.cid, parent.name FROM geo AS node, geo AS parent
    WHERE parent.lft &lt; node.lft AND node.lft &lt; parent.rgt AND node.cid = 11
    ORDER BY parent.lft DESC LIMIT 1;
</code></pre> <h2>Total Number of Child Nodes</h2><p>Calculate using the node's own lft and rgt. According to the nested model, each child node uses two numbers, so the total number of child nodes is (rgt-lft-1)/2. For example, Beijing's rgt=13, lft=2, so its total number of child nodes is (13-2-1)/2 = 5.</p><h2>Number of Direct Child Nodes and Whether There Are Child Nodes</h2><p>First, use the node's left and right boundaries and depth as conditions. For example, the root's lft=1, rgt=20. Nested queries are not needed, but an additional query may be required.</p> <pre><code class="language-sql">SELECT count(1) AS num FROM geo WHERE lft&gt;1 AND rgt&lt;22 AND depth=1+1;
</code></pre> <p>Using nested queries, with the node ID as the condition, such as Beijing's cid=2:</p> <pre><code class="language-sql">SELECT count(1) AS num
FROM geo AS n , geo AS s
WHERE s.cid=2 AND n.lft&gt;=s.lft AND n.rgt&lt;=s.rgt AND n.depth=s.depth+1;
</code></pre> <h2>Deleting Nodes</h2><p>To simplify the logic, I only handle deleting leaf nodes or entire subtrees, not handling the problem of orphaned nodes caused by deleting middle-level nodes. In actual business, usually more nodes are added and fewer are deleted, and many projects don't delete nodes at all.</p><p>First, calculate the offset caused by deleting related nodes. For example, to delete Xicheng, lft=7, rgt=8, offset = 8-7+1 = 2:</p> <pre><code class="language-sql">//Delete the current node and its child nodes to be deleted
DELETE FROM geo WHERE lft&gt;=7 AND rgt&lt;=8;

//Recalibrate the left boundary of all nodes whose left boundary is greater than the deleted node's right boundary
UPDATE geo SET lft=lft-2 WHERE lft&gt;8;

//Same as above, recalibrate the right boundary of all nodes whose right boundary is greater than the deleted node's right boundary
UPDATE geo SET rgt=rgt-2 WHERE rgt&gt;8;
</code></pre> <h2>Sibling Node Reordering</h2><p>Generally, sibling node reordering doesn't require write operations. We only handle the sorting of the retrieved results. The above SQL is all sorted by lft, that is, sorted by the order of addition. However, usually when displaying sibling child nodes, they need to be sorted alphabetically or phonetically. The solution is: if the display is in English, sort directly by English; if the display is in Chinese, add a redundant field to store the pinyin when adding records, and sort by pinyin when retrieving.</p><hr><p><em>Original Link: https://www.snowpeak.fun/en/article/detail/further_discussion_on_managing_hierarchical_data_with_nested_set_model/</em></p></main><footer class="footer"><div class="container"><div class="footer-content"><div class="footer-section"><h3><i class="fas fa-snowflake"></i> Snowpeak</h3><p>Sharing and discussing cutting-edge technologies of AI and cloud computing, and other interesting topics.</p><div class="social-links"><div class="social-platforms"><a href="https://github.com/xfsnow" target="_blank" class="social-link"><i class="fab fa-github"></i></a><a href="https://snowpeak.blog.csdn.net/" target="_blank" class="social-link"><i class="fas fa-blog"></i></a><a href="https://space.bilibili.com/701839928" target="_blank" class="social-link"><i class="fab fa-bilibili"></i></a><a href="https://www.linkedin.com/in/snowpeak" target="_blank" class="social-link"><i class="fab fa-linkedin"></i></a></div><div class="wechat-section"><div class="wechat-info"><span class="wechat-label">WeChat Account</span><span class="wechat-name">Tech Warm Life</span></div><img src="/assets/img/techwarm.jpg" alt="Tech Warm Life" class="wechat-qr"></div></div></div><div class="footer-section"><h4>Quick Links</h4><ul><li><a href="/#articles">Article</a></li><li><a href="/#tools">Tools</a></li><li><a href="https://docs.github.com/en/pages" target="_blank">GitHub Pages</a></li></ul></div><div class="footer-section"><h4>Tech Stack</h4><ul><li>Python</li><li>GitHub Copilot</li><li>Claude Sonnet 4</li><li>HTML/CSS/JS</li><li>Responsive Design</li></ul></div></div><div class="footer-bottom"><p>Copyright &copy; 2013-<script>document.write((new Date()).getFullYear());</script> Snowpeak Blog. Running on GitHub Pages. <a href="https://beian.miit.gov.cn" target="_blank" class="icp_beian">京ICP备2021007720号</a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502052523" target="_blank" class="gongan_beian">京公网安备11010502052523号</a></p></div></div></footer><script src="/en/index.js"></script><script src="/assets/js/blog.min.js"></script><script>hljs.highlightAll();</script></body></html>