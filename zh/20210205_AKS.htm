<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>雪峰博客</title><meta name="description" content="分享AI和云计算技术的最新动态与实践经验，以及其它有趣的话题。"><meta name="keywords" content="AI, GitHub Copilot, Azure云, 云计算, 前端技术, 后端技术, Web开发, 软件工程"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.7.2/css/all.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script></head><body><nav class="navbar"><div class="nav-container"><div class="nav-logo"><h2><i class="fas fa-snowflake"></i> Snowpeak</h2></div><div class="nav-menu"><a href="/" class="nav-link">首页</a><a href="/zh/page_1.htm" class="nav-link">文章</a><a href="/#tools" class="nav-link">工具</a><a href="/zh/about.htm" class="nav-link">关于</a><a href="/en/" class="nav-link lang-switch"><i class="fas fa-globe"></i> English</a></div><div class="nav-toggle" id="mobile-menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></div></div></nav><header class="article-header"><div class="container"><h1>在微软云AKS上部署弹性应用</h1><div class="article-meta"><span><i class="fas fa-calendar"></i> 发布时间: 2021-02-05 16:25:06</span><span><i class="fas fa-clock"></i> 阅读约需: 13 分钟 </span><span><i class="fas fa-tag"></i> 分类: 工具</span></div></div></header><main class="article-container"><p>Azure Kubernetes 服务 (AKS)是微软云Azure上托管的Kubernetes 群集，可以用于快速部署Kubernetes 群集，结合Azure其它服务和功能，简化日常运维，轻松实现业务应用的弹性。本文是一个动手小实验，演示弹性部署的基本步骤。适用的场景是在AKS背后的虚拟机意外停机时，通过Kubernetes 的配置实现自动故障转移。</p><p>阅读本文需要掌握<a href="https://kubernetes.io/zh/">Kubernetes的基本知识和操作</a>，以及AKS的<a href="https://docs.azure.cn/zh-cn/aks/">基本概念</a>和<a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md">部署</a>。</p><h2>基本部署</h2><h3>应用</h3><p>演示用的应用源码在这里</p><p><a href="https://github.com/xfsnow/pipelines-javascript-docker/">https://github.com/xfsnow/pipelines-javascript-docker/</a></p><p>请先fork到自己的GitHub账号下。</p><p>这个应用是个非常简单的Node.js 应用，用来输出时间和运行的主机名，用以演示负载均衡后具体运行在哪个后端上。主要文件只有一个</p><p><a href="https://github.com/xfsnow/pipelines-javascript-docker/blob/a0aa063b97d6d6819c2adcdcea9b11e47959a86b/app/server.js#L19">https://github.com/xfsnow/pipelines-javascript-docker/blob/a0aa063b97d6d6819c2adcdcea9b11e47959a86b/app/server.js#L19</a></p><p>输出内容就是下面这行：</p> <pre><code>res.send('Hello world! Now is '+now+'.\nRunning on '+os.hostname()+'.');
</code></pre> <p>Kubernetes的部署文件主要是manifests/hello-deployment.yml，以 4 个replica部署一个deployment。这个配置文件的声明和作用都写在相关注释里了。核心原理是使用</p><h1>通过 toleration 来检测节点状态，一旦发现节点不可用，则不再置放 pod</h1><p>tolerations:</p><p>- key: "node.kubernetes.io/unreachable"</p><p>operator: "Exists"</p><p>effect: "NoExecute"</p><p>tolerationSeconds: 1</p><p>- key: "node.kubernetes.io/not-ready"</p><p>operator: "Exists"</p><p>effect: "NoExecute"</p><p>tolerationSeconds: 1</p><p>以及</p><h1>健康检查，通过 httpGet 检查应用运行状态</h1><p>livenessProbe:</p><p>httpGet:</p><p>port: 80</p><p>scheme: HTTP</p><p>path: /</p><h1>初始化延迟 3 秒，用于应用首次启动时等待的时间，避免首次启动慢误判为失败。</h1><p>initialDelaySeconds: 10</p><h1>之后检查的间隔时间</h1><p>periodSeconds: 1</p><h1>超时多久认为是失败</h1><p>timeoutSeconds: 3</p><p>另有一个hello-service.yml，部署了一个负载均衡器，暴露出公网IP对外提供服务。这个负载均衡器也还有健康检查，在发现后端pod不可用时，会把其撤掉，然后再把新生成的pod挂载上来。</p><h3>Azure资源</h3><p>一个ACR，用于保存容器镜像，注意目前只有东2区域可以支持az acr build 命令在本地直接构建并推送到ACR。所以我们创建的ACR资源在东2区，而AKS集群可以在任何一个国内的区域。</p><h1>定义环境变量</h1><p>REGION_NAME=ChinaEast2</p><p>RESOURCE_GROUP=aksResilience</p><p>AKS_CLUSTER_NAME=aksResilience</p><p>ACR_NAME=acr$RANDOM</p><h1>创建资源组</h1><p>az group create --location $REGION_NAME --name $RESOURCE_GROUP</p><h1>创建ACR</h1><p>az acr create --resource-group $RESOURCE_GROUP --name $ACR_NAME --location $REGION_NAME --sku Standard</p><p>列表看一下结果</p><p><code>az acr list -o table</code></p><p><code>NAME RESOURCE GROUP LOCATION SKU LOGIN SERVER CREATION DATE ADMIN ENABLED</code></p><p><code>-------- ---------------- ----------- ----- ------------------- -------------------- ---------------</code></p><p><code>acr11044 aksResilience chinaeast2 Standard acr11044.azurecr.cn 2021-02-05T03:12:36Z False</code></p><h1>创建 AKS 集群</h1><p>az aks create \</p><p>--resource-group $RESOURCE_GROUP \</p><p>--name $AKS_CLUSTER_NAME \</p><p>--location $REGION_NAME \</p><p>--node-count 2 \</p><p>--enable-addons monitoring \</p><p>--generate-ssh-keys</p><p>这步比较慢，请耐心等待，直到有返回结果。</p><p>列一下 AKS集群</p><p><code>az aks list -o table</code></p><p><code>Name Location ResourceGroup KubernetesVersion ProvisioningState Fqdn</code></p><p><code>------------- ----------- --------------- ------------------- -------------------</code></p><p><code>aksResilience chinanorth2 aksResilience 1.18.14 Succeeded</code></p><h1>把 ACR 绑定到AKS集群上，这样就可以自动验证从ACR拉取镜像到AKS集群了</h1><p>az aks update \</p><p>--name $AKS_CLUSTER_NAME \</p><p>--resource-group $RESOURCE_GROUP \</p><p>--attach-acr $ACR_NAME</p><p>这步比较慢，请耐心等待，直到有返回结果。</p><p>到此，Azure资源已创建完毕，总共1个AKS集群，包含1个虚拟机扩展集，其中有2台虚拟机。</p><p>列一下 AKS集群背后的虚拟机扩展集。注意这里的虚拟机扩展集由Azure自动创建在另一个资源组里。</p><p><code>az vmss list -o table</code></p><p><code>Name ResourceGroup Location Zones Capacity Overprovision UpgradePolicy</code></p><p><code>--------------------------- ------------------------------------------ ----------- ------- ---------- --------------- ---------------</code></p><p><code>aks-nodepool1-40474697-vmss MC_AKSRESILIENCE_AKSRESILIENCE_CHINANORTH2 chinanorth2 2 False Manual</code></p><p>最后列一下虚拟机扩展集中的实例</p><p>az vmss list-instances \</p><blockquote><p>-g MC_AKSRESILIENCE_AKSRESILIENCE_CHINANORTH2 \</p><p>-n aks-nodepool1-40474697-vmss \</p><p>-o table \</p><p>--query "[].{instanceId:instanceId, Name:name, State:provisioningState}"</p></blockquote><p>InstanceId Name State</p><p>------------ ----------------------------- ---------</p><p>0 aks-nodepool1-40474697-vmss_0 Succeeded</p><p>1 aks-nodepool1-40474697-vmss_1 Succeeded</p><h3>部署Kubernetes</h3><h4>构建镜像推送到镜像注册表。</h4><p>git clone <a href="https://github.com/xfsnow/pipelines-javascript-docker/">https://github.com/xfsnow/pipelines-javascript-docker/</a></p><p>拉取源码。</p><p>先构建并推送镜像</p><p>cd app</p><p>az acr build \</p><p>--resource-group $RESOURCE_GROUP \</p><p>--registry $ACR_NAME \</p><p>--image helloworld:1.0 .</p><p>然后获取镜像注册表具体的URL</p><p>az acr repository show -n $ACR_NAME --repository helloworld --query "registry"</p><p>"acr11044.azurecr.cn"</p><p>记下这个形如acr11044.azurecr.cn的URL，后面接上helloworld:1.0就是完整的镜像拉取地址，形如</p><p>acr11044.azurecr.cn/helloworld:1.0</p><p>cd manifests，</p><p>找到 hello-deployment.yml 中的这行</p><h1>容器镜像使用 Azure 上的 ACR 服务。</h1><p>image: snowpeak.azurecr.cn/helloworld:1.3</p><p>替换成你自己的 ACR 镜像的URL “acr11044.azurecr.cn/helloworld:1.0”。</p><h4>连接AKS集群并部署镜像</h4><p>连接AKS集群</p><p>az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_CLUSTER_NAME</p><p>先查看一下AKS集群中的节点</p><p>kubectl get nodes -o wide</p><p>NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUN</p><p>TIME</p><p>aks-nodepool1-40474697-vmss000000 Ready agent 142m v1.18.14 10.240.0.4 <none> Ubuntu 18.04.5 LTS 5.4.0-1035-azure docker://19.3</p><p>.14</p><p>aks-nodepool1-40474697-vmss000001 Ready agent 142m v1.18.14 10.240.0.5 <none> Ubuntu 18.04.5 LTS 5.4.0-1035-azure docker://19.3</p><p>.14</p><p>再看一下pod。</p><p>kubectl get pods -o wide</p><p>No resources found in default namespace.</p><p>此时尚未部署镜像，所以没有资源。</p><p>然后用 cd ../manifests/ 来到Kubernetes 配置文件目录下。</p><p>kubectl apply -f hello-deployment.yml和 kubectl apply -f hello-service.yml 部署到 AKS 集群中。部署好的集群初始是这样的。</p><p><code>kubectl get pods -o wide</code></p><p><code>NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES</code></p><p><code>helloworld-869d58f588-5tmpf 1/1 Running 0 71s 10.244.1.6 aks-nodepool1-40474697-vmss000001 &lt;none&gt; &lt;none&gt;</code></p><p><code>helloworld-869d58f588-bt54r 1/1 Running 0 71s 10.244.1.7 aks-nodepool1-40474697-vmss000001 &lt;none&gt; &lt;none&gt;</code></p><p><code>helloworld-869d58f588-qh6hn 1/1 Running 0 71s 10.244.0.6 aks-nodepool1-40474697-vmss000000 &lt;none&gt; &lt;none&gt;</code></p><p><code>helloworld-869d58f588-w8xbx 1/1 Running 0 71s 10.244.0.7 aks-nodepool1-40474697-vmss000000 &lt;none&gt; &lt;none&gt;</code></p><p>这是运行起来的4个pod，每个节点上2个pod。</p><p><code>kubectl get services</code></p><p><code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</code></p><p><code>helloworld LoadBalancer 10.0.116.133 139.217.112.135 80:30754/TCP 7d17h</code></p><p>这是部署起来的LoadBalancer，外网IP 139.217.112.135 可以直接访问，返回的结果如下：</p><p><code>curl http://139.217.112.135/;</code></p><p><code>Hello world! Now is 2021-02-04 08:26:52.924.</code></p><p><code>Running on helloworld-745c979464-q54vd.</code></p><p>这里Running on helloworld-745c979464-q54vd. 正是上述1个pod的名称。</p><p>如果连续请求多次，会看到请求大致均匀地分发到4个后端pod上。</p><p>while(true); do curl --connect-timeout 2 http://139.217.112.135/; echo -e '\n'; sleep 0.5; done</p><p>Hello world! Now is 2021-02-04 08:34:19.523.</p><p>Running on helloworld-745c979464-q54vd.</p><p>Hello world! Now is 2021-02-04 08:34:20.160.</p><p>Running on helloworld-745c979464-ljrcv.</p><p>Hello world! Now is 2021-02-04 08:34:20.798.</p><p>Running on helloworld-745c979464-97v26.</p><p>Hello world! Now is 2021-02-04 08:34:21.427.</p><p>Running on helloworld-745c979464-q54vd.</p><p>Hello world! Now is 2021-02-04 08:34:22.56.</p><p>Running on helloworld-745c979464-l2jpm.</p><p>Hello world! Now is 2021-02-04 08:34:22.697.</p><p>Running on helloworld-745c979464-ljrcv.</p><p>Hello world! Now is 2021-02-04 08:34:23.368.</p><p>Running on helloworld-745c979464-l2jpm.</p><p>Hello world! Now is 2021-02-04 08:34:24.6.</p><p>Running on helloworld-745c979464-ljrcv.</p><p>Hello world! Now is 2021-02-04 08:34:24.659.</p><p>Running on helloworld-745c979464-l2jpm.</p><h2>模拟故障</h2><p>我们手工停止一台虚拟机，模拟虚拟机发生故障的情况。</p><ol><li>我们先打开实时观察 pod 运行状况</li></ol><p>kubectl get po -o wide -w</p><ol><li>再开一个新窗口运行</li></ol><p>while(true); do curl --connect-timeout 2 http://139.217.112.135/; echo -e '\n'; sleep 0.5; done</p><p>来看访问应用的情况</p><ol><li>再开一个窗口执行停止一台虚拟机的命令</li></ol><p>az vmss stop -g MC_DEMO_HELLOWORLD_CHINANORTH2 -n aks-agentpool-11798053-vmss --instance-id 0</p><ol><li>回到第一个窗口，查看 pod 运行情况，看到类似如下的返回。</li></ol><p>kubectl get po -o wide -w</p><p>NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES</p><p>helloworld-9bbdbf45b-2hnz4 1/1 Running 0 119s 10.240.0.152 aks-agentpool-11798053-vmss000001 <none><none></p><p>helloworld-9bbdbf45b-64qt4 1/1 Terminating 0 6m41s 10.240.0.106 aks-agentpool-11798053-vmss000000 <none><none></p><p>helloworld-9bbdbf45b-gczpn 1/1 Running 0 6m37s 10.240.0.135 aks-agentpool-11798053-vmss000001 <none><none></p><p>helloworld-9bbdbf45b-l6dxm 1/1 Terminating 0 5m11s 10.240.0.68 aks-agentpool-11798053-vmss000000 <none><none></p><p>helloworld-9bbdbf45b-rhn2m 1/1 Terminating 0 4m45s 10.240.0.42 aks-agentpool-11798053-vmss000000 <none><none></p><p>helloworld-9bbdbf45b-smtft 1/1 Running 0 118s 10.240.0.185 aks-agentpool-11798053-vmss000001 <none><none></p><p>helloworld-9bbdbf45b-tmdkr 1/1 Running 0 119s 10.240.0.149 aks-agentpool-11798053-vmss000001 <none><none></p><p>第1个节点上的pod显示正在停止，而新的pod运行在第2个节点上。</p><ol><li>再来到运行curl的窗口查看</li></ol><p>while(true); do curl --connect-timeout 2 http://139.217.112.135/; echo -e '\n'; sleep 0.5; done</p><p>curl: (28) Connection timed out after 2013 milliseconds</p><p>…</p><p>curl: (28) Connection timed out after 2009 milliseconds</p><p>…</p><p>Hello world! Now is 2021-02-04 01:40:37.752.</p><p>Running on helloworld-9bbdbf45b-2vjxt.</p><p>Hello world! Now is 2021-02-04 01:40:38.409.</p><p>Running on helloworld-9bbdbf45b-vpvn6.</p><p>Hello world! Now is 2021-02-04 01:40:39.57.</p><p>Running on helloworld-9bbdbf45b-2vjxt.</p><p>Hello world! Now is 2021-02-04 01:40:39.736.</p><p>在出现若干次超时后，返回结果恢复正常了，并且主机名出现了新的pod名称。</p><p>仔细查看输出内容的时间，可以看到超时经历的时间不超过1分钟。</p><ol><li>最后我们再恢复节点运行</li></ol><p>可以看到原来停止的节点上的pod显示为正常Terminating并最终消失，现有4个pod都运行在第2个节点上。可以通过设置replicas 来重新均衡置放pod。</p><h2>资源清理</h2><p>az group delete --name $RESOURCE_GROUP --yes</p><p>删除该资源组及其所有资源，实验结束。</p></main><footer class="footer"><div class="container"><div class="footer-content"><div class="footer-section"><h3><i class="fas fa-snowflake"></i> Snowpeak</h3><p>分享AI和云计算技术的最新动态与实践经验，以及其它有趣的话题。</p><div class="social-links"><div class="social-platforms"><a href="https://github.com/xfsnow" target="_blank" class="social-link"><i class="fab fa-github"></i></a><a href="https://snowpeak.blog.csdn.net/" target="_blank" class="social-link"><i class="fas fa-blog"></i></a><a href="https://space.bilibili.com/701839928" target="_blank" class="social-link"><i class="fab fa-bilibili"></i></a><a href="https://www.linkedin.com/in/snowpeak" target="_blank" class="social-link"><i class="fab fa-linkedin"></i></a></div><div class="wechat-section"><div class="wechat-info"><span class="wechat-label">微信公众号</span><span class="wechat-name">技术温暖生活</span></div><img src="/assets/img/techwarm.jpg" alt="技术温暖生活" class="wechat-qr"></div></div></div><div class="footer-section"><h4>快速链接</h4><ul><li><a href="/#articles">文章</a></li><li><a href="/#tools">工具</a></li><li><a href="https://docs.github.com/en/pages" target="_blank">GitHub Pages</a></li></ul></div><div class="footer-section"><h4>技术栈</h4><ul><li>Python</li><li>GitHub Copilot</li><li>Claude Sonnet 4</li><li>HTML/CSS/JS</li><li>响应式设计</li></ul></div></div><div class="footer-bottom"><p>Copyright &copy; 2013-<script>document.write((new Date()).getFullYear());</script> 雪峰博客。运行在 GitHub Pages 上。 <a href="https://beian.miit.gov.cn" target="_blank" class="icp_beian">京ICP备2021007720号</a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502052523" target="_blank" class="gongan_beian">京公网安备11010502052523号</a></p></div></div></footer><script src="/zh/index.js"></script><script src="/assets/js/blog.js"></script><script>hljs.highlightAll();</script></body></html>